---
title: "Rustã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è‡ªä½œã—ã¦ã¿ã‹ã‚“æœ¬3.3(day03a)ã®å†…å®¹ã‚’ã‚„ã‚‹"
emoji: "ğŸŠ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [rust, os]
published: true
---

# ã¯ã˜ã‚ã«
https://book.mynavi.jp/ec/products/detail/id=121220
ã‚¼ãƒ­ã‹ã‚‰ã®è‡ªä½œOSå…¥é–€(ã¿ã‹ã‚“æœ¬)ã®ã€Œ3.3 åˆã‚ã¦ã®ã‚«ãƒ¼ãƒãƒ«(osbook_day03a)ã€ã‚’Rustã§è¡Œã†å ´åˆã€æ›¸ç±å†…ã§ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚„ãƒªãƒ³ã‚«ã«æ¸¡ã—ã¦ã„ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã©ã®ã‚ˆã†ã«Rustã§å†ç¾ã™ã‚Œã°è‰¯ã„ã‹ã¨ã„ã†ã¨ã“ã‚ã§å°‘ã—è©°ã¾ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã—ãŸ(ã‚‚ã¡ã‚ã‚“ã€UEFIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ“ãƒ«ãƒ‰ã‚‚å›°ã£ãŸ)ã€‚
ãã‚‚ãã‚‚Rustã‚‚Clangã‚‚åŸºç›¤ã¯LLVMãªã®ã§Clangã§ã‚„ã£ã¦ã„ã‚‹ã‚ˆã†ãªã“ã¨ã¯åŸºæœ¬çš„ã«Rustã§ã‚‚å¯èƒ½ãªã¯ãšã§ã‚ã‚‹ã¨è€ƒãˆã¦èª¿ã¹ãŸã¨ã“ã‚ã€[The Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)ã§ç´¹ä»‹ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è‡ªä½œã™ã‚‹ã—ã£ãã‚ŠããŸã®ã§è¨˜è¼‰ã—ã¾ã™ã€‚

# ç’°å¢ƒ
```
> wsl --list --running
Linux ç”¨ Windows ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ  ãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³:
Ubuntu-20.04 (æ—¢å®š)
```

```
$ rustup --version
rustup 1.24.3 (ce5817a94 2021-05-31)
info: This is the version for the rustup toolchain manager, not the rustc compiler.
info: The currently active `rustc` version is `rustc 1.59.0-nightly (c09a9529c 2021-12-23)`
$ cargo --version
cargo 1.59.0-nightly (fcef61230 2021-12-17)
```

rustcã®`unstable-options`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚„ã€`no_std`ã®ç’°å¢ƒãªã®ã§`nightly`ã‚’ä½¿ã„ã¾ã™ã€‚

# ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå®šç¾©ç”¨ã®JSONãƒ•ã‚¡ã‚¤ãƒ«
```json:./x86_64-unknown-elf.json
{
    "abi-return-struct-as-int": true,
    "allows-weak-linkage": false,
    "arch": "x86_64",
    "cpu": "x86-64",
    "data-layout": "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    "disable-redzone": true,
    "emit-debug-gdb-scripts": false,
    "exe-suffix": ".elf",
    "executables": true,
    "features": "-mmx,-sse,+soft-float",
    "is-builtin": false,
    "is-like-msvc": false,
    "is-like-windows": false,
    "linker": "ld.lld",
    "linker-flavor": "ld",
    "linker-is-gnu": true,
    "llvm-target": "x86_64-elf",
    "max-atomic-width": 64,
    "os": "none",
    "panic-strategy": "abort",
    "pre-link-args": {
        "ld": [
            "--entry=kernel_main",
            "--image-base=0x100000",
            "--static",
            "-z",
            "norelro"
        ]
    },
    "singlethread": true,
    "split-debuginfo": "packed",
    "stack-probes": {
        "kind": "call"
    },
    "target-pointer-width": "64"
}
```

`"exe-suffix": ".elf"`ã§å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã‚’`.elf`ã«æŒ‡å®šã§ãã¾ã™ã€‚ä¸è¦ãªå®šç¾©ã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
ãã‚Œãã‚Œã®å€¤ã¯[rustc_target::spec](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/index.html)ã®`Target`ã‚„`TargetOption`æ§‹é€ ä½“ã«å®šç¾©ãŒã‚ã‚Šã€ãã®è©³ç´°ã«é–¢ã—ã¦ã¯LLVMã‚„Clangã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã™ã‚‹ã¨è‰¯ã„ã§ã—ã‚‡ã†ã€‚

## å¯¾å¿œã™ã‚‹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚ªãƒ—ã‚·ãƒ§ãƒ³
+ `--targetx86_64-elf` = `"llvm-target": "x86_64-elf"`
[Cross-compilation using Clang -- Clang 13 documentation](https://clang.llvm.org/docs/CrossCompilation.html)ã®Target Triplesã«ã‚ã‚‹ã‚ˆã†ã«ã€`<arch><sub>-<vendor>-<sys>-<abi>`ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§è¡¨ã•ã‚Œã‚‹ã‚‚ã®ã‚’æŒ‡å®šã™ã‚‹ã€‚Rustã®Targetã¯å‰è¿°ã®JSONã®ã‚ˆã†ãªè¨­å®šã‚’å‚ç…§ã—ã¦ã„ã‚‹ã ã‘ãªã®ã§æ³¨æ„ã€‚
`x86_64-unknown-uefi`ã‚‚LLVMã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯`x86_64-unknown-windows`ã§ã€ã¿ã‹ã‚“æœ¬ã®`x86_64-pc-win32-coff`ã§ã¯ãªã„ã§ã™ã€‚çµå±€PEãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã ã‹ã‚‰ãƒªãƒ³ã‚«ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã•ãˆ`/subsystem:efi_application`ã§ã‚ã‚Œã°å¤§ä¸ˆå¤«ï¼Ÿ

+ `-fno-exception` = `"panic-strategy": "abort"`
ãƒ‘ãƒ‹ãƒƒã‚¯æ™‚ã€ã‚¹ã‚¿ãƒƒã‚¯ã®å·»ãæˆ»ã—ã‚’è¡Œã‚ãªã„ï¼Ÿ

+ `-mno-red-zone` = `"disable-redzone" : true`
ã¿ã‹ã‚“æœ¬ã‚³ãƒ©ãƒ 3.1ã‚’å‚ç…§ã€‚

## ãƒªãƒ³ã‚«ã‚ªãƒ—ã‚·ãƒ§ãƒ³
```json
"pre-link-args": {
        "ld": [
            "--entry=kernel_main",
            "--image-base=0x100000",
            "--static",
            "-z",
            "norelro"
        ]
    },
```

`"-z norelro"`ã¨ã¯æ›¸ã‘ãªã„ã®ã§æ³¨æ„ã€‚

# config.toml
```toml:./.cargo/config.toml
[build]
target = "./x86_64-unknown-elf.json"

[unstable]
build-std = ["core"]
```

`no_std`ãªç’°å¢ƒãªã‚‰Rustã®coreã‚¯ãƒ¬ãƒ¼ãƒˆã¯å¿…é ˆã€‚ãƒ¡ãƒ¢ãƒªç®¡ç†ãªã©è¿½åŠ ã—å§‹ã‚ãŸã‚‰ã“ã¡ã‚‰ã«ã‚‚`alloc`ãªã©ã¯è¿½åŠ ã™ã‚‹å¿…è¦ã¯ã‚ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

`cargo build -Z build-std=core --target=./x86_64-unknown-elf.json`ã¨åŒç¾©ã§ã™ã€‚

# main.rs
```rust:./src/main.rs
#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[no_mangle]
extern "C" fn kernel_main() {
    loop {
        unsafe {
            core::arch::asm!("hlt");
        }
    }
}

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {
        unsafe {
            core::arch::asm!("hlt");
        }
    }
}
```
Rustã§ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã‚’ä½¿ã†å ´åˆã¯`asm!`ãƒã‚¯ãƒ­ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
ç¾åœ¨(1.59.0-nightly)ã§ã¯ã„ãã¤ã‹ã®ä¾‹ã«ç™»å ´ã™ã‚‹`#![features(asm)]`ã¯ä¸è¦ã«ãªã£ã¦ã„ã¾ã™ã€‚

# Cargo.toml
```toml:Cargo.toml
[package]
name = "kernel"
version = "0.1.0"
edition = "2021"
```

ä»Šå›ã€`Cargo.toml`ã«ç‰¹åˆ¥è¨­å®šã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

# ãƒ“ãƒ«ãƒ‰
```
$ cargo build
// ç•¥

$ readelf -h ./target/x86_64-unknown-elf/debug/kernel.elf
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x101000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          9944 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         4
  Size of section headers:           64 (bytes)
  Number of section headers:         16
  Section header string table index: 14
```

ç„¡äº‹ã€ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’`0x101000`ã«è¨­å®šã§ãã¾ã—ãŸã€‚

## QEMUã§ç¢ºèª
:::message
QEMUã®å®Ÿè¡Œã«é–¢ã—ã¦ã¯ã¿ã‹ã‚“æœ¬ã‚’å‚ç…§ä¸‹ã•ã„ã€‚
:::

``` 
(qemu) info registers
RAX=0000000000101000 RBX=0000000000000000 RCX=0000000000000000 RDX=0000000000000000
RSI=000000003fec93d0 RDI=000000003e7711c0 RBP=000000003e7711c8 RSP=000000003feaa5c0
R8 =000000003feaa4b4 R9 =000000003fb7b48f R10=000000003fbcd018 R11=fffffffffffffffc
R12=000000003e771418 R13=000000003effef18 R14=8000000000000002 R15=0000000000000131
RIP=0000000000101004 RFL=00000046 [---Z-P-] CPL=0 II=0 A20=1 SMM=0 HLT=1
```

```
(qemu) x /2i 0x101004
0x00101004:  eb fd                    jmp      0x101003
0x00101006:  cc                       int3     
(qemu) x /2i 0x101003
0x00101003:  f4                       hlt      
0x00101004:  eb fd                    jmp      0x101003
```

HLTå‘½ä»¤ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã‚‰ã—ãã“ã¨ãŒç¢ºèªã§ãã¾ã™ã€‚[`int3`](https://en.wikipedia.org/wiki/INT_(x86_instruction)#INT3)ã¯UEFIãƒ­ãƒ¼ãƒ€ã®`unreachable!()`ã§ã—ã‚‡ã†ã‹ã€‚

# çµ‚ã‚ã‚Šã«
è‡ªä½œOSã‚„çµ„è¾¼ãªã©ã®ãƒ™ã‚¢ãƒ¡ã‚¿ãƒ«ç’°å¢ƒã§ã‚ã‚Œã°ã€å¯¾è±¡ã«å¿œã˜ãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ä½œã£ãŸæ–¹ãŒæ¥½ãªå ´åˆã‚‚å¤šã„ã§ã—ã‚‡ã†ã€‚Rustã‚‚åŸºç›¤ã¯LLVMãªã®ã§Clangã§å‡ºæ¥ã‚‹äº‹ã¯Rustã§ã‚‚è¨€èªçš„ãªåˆ¶ç´„ã•ãˆãªã‘ã‚Œã°ã§ãã‚‹ã¯ãšã§ã™ã€‚

# ä»˜éŒ²
## ãã®ä»–å‚è€ƒ
https://docs.rust-embedded.org/embedonomicon/custom-target.html

https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/index.html

https://uefi.org/sites/default/files/resources/UEFI_Spec_2_9_2021_03_18.pdf

## ãƒ­ãƒ¼ãƒ€ãƒ¼ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰
ã‚ªãƒ¬ã‚ªãƒ¬UEFIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³SDKã‚’ä½¿ã£ã¦ã„ã¾ã™ãŒä»Šå›ã¯ç‰¹ã«ç´¹ä»‹ã—ã¾ã›ã‚“ã€‚ä¸€å¿œã€æ§‹é€ ã‚’`std`ã«å¯„ã›ãŸã‚Šã€`println!`ãƒã‚¯ãƒ­ã‚’ä½¿ã£ã¦ç”»é¢ã«æ–‡å­—è¡¨ç¤ºã—ãŸã‚Šã§ãã‚‹ã‚ˆã†ã«ã¯ã—ã¦ã‚ã£ãŸã‚Šã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§å–å¾—ã§ã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’åˆ‡ã‚Šæ›¿ãˆãŸã‚Šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãªã©ã—ã¦ã‚ã‚Šã¾ã™ã€‚

https://github.com/rust-osdev/uefi-rs
ç‰¹ã«ç†ç”±ãŒãªã‘ã‚Œã°è‡ªåˆ†ã§æ§‹é€ ä½“å®šç¾©ã‹ã‚‰æ›¸ã„ãŸã‚Šã›ãš`uefi-rs`ã‚’ä½¿ã£ãŸæ–¹ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚

```rust
#![no_std]
#![no_main]

use uefi::*;
use uefi::protocol::EfiLoadedImageProtocol;
use uefi::protocol::file::{EfiSimpleFileSystemProtocol, EfiFileProtocol, EfiFileInfo};
use uefi::types::EfiHandle;

fn open_root() -> &'static mut EfiFileProtocol {
    let image_handle = uefi::image_handle();
    let p = uefi::system_table().boot_services().open_protocol::<EfiLoadedImageProtocol>(
        image_handle, 
        image_handle, 
        EfiHandle::null(), 
        1).unwrap();
    let fs = uefi::system_table().boot_services().open_protocol::<EfiSimpleFileSystemProtocol>(
        p.device_handle,
        image_handle,
        EfiHandle::null(),
        1
    ).unwrap();
    fs.open_volume().unwrap()
}

#[no_mangle]
unsafe fn main() {
    let mut buf : [u8; 1024*8] =  [0; 1024*8];
    let memmap= uefi::system_table().boot_services().mem_service().get_memory_map(&mut buf).unwrap();
    
    let root = open_root();
    let mut filename = String16::from_str("\\kernel.elf");
    let kernel_file = root.open(
        &mut filename, 
        EfiFileProtocol::EFI_FILE_MODE_READ).unwrap();

    let kernel_info = kernel_file.get_info::<EfiFileInfo<12>>().unwrap();

    let mut kernel_file_size = kernel_info.filesize as usize;
    let mut kernel_base_addr = 0x100000;

    system_table().boot_services().mem_service().alloc_pages(
        services::mem::AllocateType::AllocateAddress, 
        services::mem::MemoryType::EfiLoaderData, 
        (kernel_file_size as usize + 0xfff) / 0x1000, &mut kernel_base_addr);

    kernel_file.read(&mut kernel_file_size, kernel_base_addr as usize as *mut core::ffi::c_void).unwrap();

    println!("Kernel: 0x{:x} ({} bytes)", kernel_base_addr, kernel_file_size);

    if let Err(_e) = system_table().boot_services().exit_boot_services(image_handle(), memmap.key()) {
        if let Ok(memmap) = system_table().boot_services().mem_service().get_memory_map(&mut buf) {
            
            if let Err(e) = system_table().boot_services().exit_boot_services(image_handle(), memmap.key()) {
                println!("Could not exit boot services. {:?}", e);
                loop {}
            }
        } else {
            println!("Could not get memory map.");
            loop {}
        }
    }
    
    let entry_addr = *((kernel_base_addr + 24) as *mut usize);
    let entry_point : extern "C" fn() = core::mem::transmute(entry_addr);
    (entry_point)();

    unreachable!()
}
```
`elf_main`ã¯`uefi`å´ã§å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚ã“ã¡ã‚‰ã‚‚The Enbedonomiconã‚’å‚è€ƒã«ã€‚

![](https://storage.googleapis.com/zenn-user-upload/e114a9935614-20220102.png)
å®Ÿè¡Œçµæœã¯ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚